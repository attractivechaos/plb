#lang racket/base

(define C
    (for*/vector ([i 9] [j 9] [k 9])
        (vector
            (+ j (* 9 i))
            (+ 81 k (* 9 (+ (quotient j 3) (* 3 (quotient i 3)))))
            (+ 162 k (* 9 i))
            (+ 243 k (* 9 j)))))

(define R (build-vector 324 (lambda (x) (make-vector 9 0))))
(let ([nr (make-vector 324 0)])
    (for ([r 729])
        (for ([k (vector-ref C r)])
            (vector-set! (vector-ref R k) (vector-ref nr k) r)
            (vector-set! nr k (add1 (vector-ref nr k))))))

(define (update! sr sc r v)
    (let ([v7 (arithmetic-shift v 7)])
        (for ([c2 4])
            (let ([i (vector-ref (vector-ref C r) c2)])
                (vector-set! sc i (+ v7 (vector-ref sc i))))))
    (let ([min 10] [min-c 0])
        (for ([c (vector-ref C r)])
            (if (> v 0)
                (for ([rr (vector-ref R c)])
                    (let* ([sr-rr (vector-ref sr rr)] [sr-rr+1 (add1 sr-rr)])
                        (vector-set! sr rr sr-rr+1)
                        (when (= 0 sr-rr)
                            (for ([cc (vector-ref C rr)]) 
                                (let ([sc-cc-1 (sub1 (vector-ref sc cc))])
                                    (vector-set! sc cc sc-cc-1)
                                    (when (< sc-cc-1 min)
                                        (set! min sc-cc-1)
                                        (set! min-c cc)))))))
                (for ([rr (vector-ref R c)])
                    (let ([sr-rr-1 (sub1 (vector-ref sr rr))])
                        (vector-set! sr rr sr-rr-1)
                        (when (= 0 sr-rr-1)
                            (for ([p (vector-ref C rr)])
                                (vector-set! sc p (add1 (vector-ref sc p)))))))))
        (bitwise-ior (arithmetic-shift min 16) min-c)))

(define (solve input-string)
    (let ([sr (make-vector 729 0)] ; times the row is forbidden by others
            [sc (make-vector 324 9)] ; bit 1-7 = allowed choices, bit 8 set if constraint has been used
            [hints 0] 
            [cr (make-vector 81 -1)] ; row chosen at step i
            [cc (make-vector 81 -1)] ; column chosen at step i
            [out (make-string 81 #\.)]) ; output string
        (for ([i 81] [c input-string])
            (let ([a 
                    (if (and (char>=? c #\1) (char<=? c #\9))
                        (- (char->integer c) (char->integer #\1))
                        -1)])
                (when (>= a 0) 
                    (update! sr sc (+ a (* 9 i)) 1)
                    (set! hints (add1 hints)))
                (string-set! out i c)))
        (let solve-loop ([n 0] [i 0] [dir 1] [cand 655360])
            (do () ([or (< i 0) (>= i (- 81 hints))])
                (when (= dir 1)
                    (vector-set! cc i (bitwise-and cand #xffff))
                    (let ([min (arithmetic-shift cand -16)])
                        (for ([c 324]) #:break (<= min 1)
                            (when (< (vector-ref sc c) min)
                                (set! min (vector-ref sc c))
                                (vector-set! cc i c)))     
                        (when (or (= min 0) (= min 10))
                            (vector-set! cr i -1)
                            (set! dir -1)
                            (set! i (sub1 i)))))
                (let ([c (vector-ref cc i)])
                    (when (and (= dir -1) (>= (vector-ref cr i) 0))
                        (update! sr sc (vector-ref (vector-ref R c) (vector-ref cr i)) -1))
                    (let find-r2 ([r2 (add1 (vector-ref cr i))])
                        (if (< r2 9)
                            (if (= 0 (vector-ref sr (vector-ref (vector-ref R c) r2)))
                                (begin
                                    (set! cand (update! sr sc (vector-ref (vector-ref R c) r2) 1))
                                    (vector-set! cr i r2)
                                    (set! i (add1 i))
                                    (set! dir 1))
                                (find-r2 (add1 r2)))
                            (begin
                                (vector-set! cr i -1)
                                (set! dir -1)
                                (set! i (sub1 i)))))))
            (when (>= i 0)
                (for ([j i])
                    (let ([r (vector-ref (vector-ref R (vector-ref cc j)) (vector-ref cr j))])
                        (string-set! out (quotient r 9) (integer->char (+ (char->integer #\1) (remainder r 9))))))
                (displayln out)
                (solve-loop (add1 n) (sub1 i) -1 cand))
            n)))

(define (read-line-stdin) (read-line (current-input-port) 'any))
(let read-input ([input (read-line-stdin)])
    (when (not (eof-object? input))
        (when (>= (string-length input) 81)
            (solve input))
        (read-input (read-line-stdin))))